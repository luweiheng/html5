<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>bind模拟实现-3</title>
</head>
<body>
    <script>
        // 第一版 修改this指向，合并参数
        Function.prototype.bindFn = function bind(thisArg){
            if(typeof this !== 'function'){
                throw new TypeError(this + 'must be a function');
            }
            // 存储函数本身
            var self = this;
            // 去除thisArg的其他参数 转成数组
            var args = [].slice.call(arguments, 1);
            // bind后的函数名 bound + 函数名
            var boundFnName = 'bound ' + self.name;
            // 声明一个对象，便于存储函数名，函数名是ES6新增的
            //  var obj[boundFnName] = function 这种写法返回的函数名为空字符串''
            var obj = {
                // 暂且采用 ES6的计算属性名语法，也可以用ES5的Object.defineProperty()来模拟，或者可以不实现函数名
                [boundFnName]: function(){
                    // bind返回的函数 的参数转成数组
                    var boundArgs = [].slice.call(arguments);
                    // apply修改this指向，把两个函数的参数合并传给self函数，并执行self函数
                    return self.apply(thisArg, args.concat(boundArgs));
                }
            };
            return obj[boundFnName];
        }
        // 测试
        var obj = {
            name: '轩辕Rowboat',
        };
        function original(a, b){
            console.log(this.name);
            console.log([a, b]);
        }
        var bound = original.bindFn(obj, 1);
        bound(2); // '轩辕Rowboat', [1, 2]
        console.log(original.bindFn.name); // 'bind'
        console.log(bound.name); // 'bound original'
        console.log((function(){}).bindFn().name); // 'bound '
    </script>
</body>
</html>